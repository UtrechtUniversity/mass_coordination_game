{% extends "otree/WaitPage.html" %}

{% block content %}
<p><strong>Waiting for the other players…</strong></p>

<p>
    Players decided: <strong>{{ arrived }}</strong> / {{ total }}
</p>

<div style="width: 100%; background: #e0e0e0; height: 18px; border-radius: 4px; overflow: hidden; margin-top: 8px;">
    <div style="
        width: {{ percent }}%;
        height: 100%;
        background: #4CAF50;
        transition: width 0.5s ease;
    "></div>
</div>

<p id="refresh-msg" style="margin-top: 12px; font-style: italic; color: gray;">
    Refreshing in <span id="countdown">10</span> seconds …
</p>

<hr style="margin: 20px 0;">


<p style="font-style: italic; text-align: center;">
    While waiting for the other players, challenge yourself with this minigame!<br>
    Press
    <span style="
        display: inline-block;
        padding: 4px 8px;
        margin: 0 4px;
        border: 1px solid #333;
        border-radius: 4px;
        background: #f0f0f0;
        font-weight: bold;
    ">
        <i class="fas fa-arrow-up"></i>
    </span>
    to jump and avoid the obstacles.
</p>

<div style="text-align:center;">
    <canvas class="dino-canvas" width="600" height="150" style="border:1px solid #ccc;"></canvas>
    <br>
    <button class="dino-start-btn" style="margin-top: 10px; padding: 6px 12px; font-size: 16px;">Start</button>
</div>

{% endblock %}

{% block scripts %}

<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
/>

<script>
    // Reload page every 10 seconds (to update progress bar and push players to the next page); pause the countdown during gameplay
    let seconds = 10;
    const countdownEl = document.getElementById('countdown');
    window.gameActive = false;  // flag whether the game is active

    const countdownInterval = setInterval(() => {
        // only decrement if the game is not active
        if (!window.gameActive) {
            seconds--;
            countdownEl.textContent = seconds;

            if (seconds <= 0) {
                clearInterval(countdownInterval);
                window.location.reload();
            }
        }
    }, 1000);
</script>


<script>
(function() {
    const canvas = document.querySelector('.dino-canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.querySelector('.dino-start-btn');
    let game = null;

    // save the highscore in the browser
    let highScore = parseInt(localStorage.getItem('dinoHighScore')) || 0;

    function createGame() {
        let dino = {x: 50, y: 120, width: 20, height: 20, dy: 0, jumping: false, jumpTime: 0};
        let gravity = 0.8;
        let jumpPower = -8; // initial jump
        let jumpHoldPower = -0.35; // small additional upward force per frame
        let maxJumpHold = 20; // max frames for holding jump
        let obstacles = [];
        let score = 0;
        let gameOver = false;
        let keys = {};

        function spawnObstacle() {
            let height = Math.random() < 0.5 ? 20 : 30;
            obstacles.push({x: 600, y: 120, width: 20, height: height});
        }

        function update() {
            if (gameOver) return;

            dino.dy += gravity;
            dino.y += dino.dy;

            if (dino.y > 120) {
                dino.y = 120;
                dino.dy = 0;
                dino.jumping = false;
                dino.jumpTime = 0;
            }

            if ((keys['ArrowUp'] || keys['Space']) && dino.jumping && dino.jumpTime < maxJumpHold) {
                dino.dy += jumpHoldPower;
                dino.jumpTime++;
            }

            obstacles.forEach(ob => { ob.x -= 6; });

            for (let ob of obstacles) {
                if (dino.x < ob.x + ob.width &&
                    dino.x + dino.width > ob.x &&
                    dino.y < ob.y + ob.height &&
                    dino.y + dino.height > ob.y) {
                    gameOver = true;
                    window.gameActive = false;

                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('dinoHighScore', highScore);
                    }

                    setTimeout(() => window.location.reload(), 800);
                }
            }

            obstacles = obstacles.filter(ob => ob.x + ob.width > 0);

            if (Math.random() < 0.02) spawnObstacle();

            score++;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "green";
            ctx.fillRect(dino.x, dino.y, dino.width, dino.height);

            ctx.fillStyle = "red";
            obstacles.forEach(ob => ctx.fillRect(ob.x, ob.y, ob.width, ob.height));

            ctx.fillStyle = "black";
            ctx.font = "16px Arial";
            ctx.fillText("Score: " + score, 10, 20);
            ctx.fillText("High Score: " + highScore, 10, 40);
        }

        function loop() {
            if (!gameOver) {
                update();
                draw();
                game.animationFrame = requestAnimationFrame(loop);
            } else {
                ctx.fillStyle = "black";
                ctx.font = "24px Arial";
                ctx.fillText("Game Over!", 230, 80);
            }
        }

        document.addEventListener('keydown', function (e) {
            keys[e.code] = true;
            if ((e.code === "Space" || e.code === "ArrowUp") && !dino.jumping) {
                dino.dy = jumpPower;
                dino.jumping = true;
                dino.jumpTime = 0; 
            }
        });

        document.addEventListener('keyup', function (e) {
            keys[e.code] = false;
        });

        game = {loop, cancel: () => cancelAnimationFrame(game.animationFrame)};
        loop();
    }

    startBtn.addEventListener('click', function () {
        startBtn.disabled = true;
        window.gameActive = true;
        createGame();
    });
})();
</script>



{% endblock %}
